import logging
from datetime import datetime, timezone

from slack_sdk import WebClient
from slack_sdk.errors import SlackApiError

from .config import Config

logger = logging.getLogger(__name__)

MAX_BLOCK_TEXT_LENGTH = 3000


class SlackPoster:
    """Posts messages to Slack using Block Kit."""

    def __init__(self, config: Config):
        self.client = WebClient(token=config.slack_bot_token)
        self.channel_id = config.slack_channel_id
        self.header = config.slack_header
        self.model_name = config.model_name

    def post_news(self, content: str) -> bool:
        """Post news content to Slack.

        Args:
            content: The news content from the LLM.

        Returns:
            True if successful, False otherwise.
        """
        blocks = self._build_blocks(content)

        try:
            response = self.client.chat_postMessage(
                channel=self.channel_id,
                blocks=blocks,
                text=self.header,
            )
            logger.info(f"Message posted successfully: {response['ts']}")
            return True
        except SlackApiError as e:
            logger.error(f"Slack API error: {e.response['error']}")
            return False

    def _build_blocks(self, content: str) -> list[dict]:
        """Build Slack Block Kit blocks for the message."""
        timestamp = datetime.now(timezone.utc).strftime("%Y-%m-%d %H:%M UTC")

        blocks = [
            {
                "type": "header",
                "text": {
                    "type": "plain_text",
                    "text": self.header,
                    "emoji": True,
                },
            },
            {"type": "divider"},
        ]

        content_blocks = self._split_content_into_blocks(content)
        blocks.extend(content_blocks)

        blocks.extend(
            [
                {"type": "divider"},
                {
                    "type": "context",
                    "elements": [
                        {
                            "type": "mrkdwn",
                            "text": f"Generated by Vertex AI {self.model_name} | {timestamp}",
                        }
                    ],
                },
            ]
        )

        return blocks

    def _split_content_into_blocks(self, content: str) -> list[dict]:
        """Split content into multiple blocks if it exceeds the limit."""
        if len(content) <= MAX_BLOCK_TEXT_LENGTH:
            return [
                {
                    "type": "section",
                    "text": {
                        "type": "mrkdwn",
                        "text": content,
                    },
                }
            ]

        blocks = []
        remaining = content

        while remaining:
            if len(remaining) <= MAX_BLOCK_TEXT_LENGTH:
                chunk = remaining
                remaining = ""
            else:
                split_pos = remaining.rfind("\n", 0, MAX_BLOCK_TEXT_LENGTH)
                if split_pos == -1:
                    split_pos = MAX_BLOCK_TEXT_LENGTH
                elif split_pos == 0:
                    # Newline at the very start would create an empty chunk; skip it.
                    remaining = remaining.lstrip("\n")
                    continue

                chunk = remaining[:split_pos]
                remaining = remaining[split_pos:].lstrip("\n")

            blocks.append(
                {
                    "type": "section",
                    "text": {
                        "type": "mrkdwn",
                        "text": chunk,
                    },
                }
            )

        return blocks
